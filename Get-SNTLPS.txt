Function Enable-SSL {
	#Import .NET Framework into Powershell session if needed -
	If (-not ([System.Management.Automation.PSTypeName]'ServerCertificateValidationCallback').Type) {
		$certCallback = @"
		using System;
		using System.Net;
		using System.Net.Security;
		using System.Security.Cryptography.X509Certificates;
		public class ServerCertificateValidationCallback
		{
			public static void Ignore()
			{
				if(ServicePointManager.ServerCertificateValidationCallback ==null)
				{
					ServicePointManager.ServerCertificateValidationCallback +=
						delegate
						(
							Object obj,
							X509Certificate certificate,
							X509Chain chain,
							SslPolicyErrors errors
						)
						{
							return true;
						};
				}
			}
		}
"@
		Add-Type $certCallback
	}
	[ServerCertificateValidationCallback]::Ignore()
	
	
	Try {
		# Set TLS 1.2 (3072), then TLS 1.1 (768), then TLS 1.0 (192)
		# Use integers because the enumeration values for TLS 1.2 and TLS 1.1 won't
		# exist in .NET 4.0, even though they are addressable if .NET 4.5+ is
		# installed (.NET 4.5 is an in-place upgrade).
		[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
	}
	Catch {
		Write-Output 'Unable to set PowerShell to use TLS 1.2 and TLS 1.1 due to old .NET Framework installed. If you see underlying connection closed or trust errors, you may need to upgrade to .NET Framework 4.5+ and PowerShell v3+.'
	}
}

Function Get-ModuleInfo {

	Write-Host 'Collecting Module Information' -ForegroundColor Cyan

	$ModuleFiles = @()

	$FunctionURLs = Invoke-WebRequest $CSVUrl -UseBasicParsing -SkipCertificateCheck -Headers @{"Cache-Control" = "no-cache" } | ConvertFrom-Csv -Delimiter ","
		
	$FunctionURLs | ForEach-Object {
		$ModuleFiles += @{
			name = $_.Verb;
			url  = $_.URL;
			path = $FunctionsFolder + $_.Verb + ".psm1";
		}
	}

	Return $ModuleFiles
}

Function Import-SNTLModules {

	Process {
		Write-Host 'Importing Modules' -ForegroundColor Cyan

		If (-not(Test-Path $FunctionsFolder)) {
			New-Item -ItemType Directory -Force -Path $FunctionsFolder | Out-Null
			$UpdateFunctions = $false
		}
	
		$ModuleInfo = Get-ModuleInfo
		$ModuleInfoLength = ($ModuleInfo).Count

		If ($ModuleInfo) {
			$i = 0;
			Do {
				ForEach ($module in $ModuleInfo) {

					$moduleName = $module.name
					$moduleURL = $module.url
					$modulePath = $module.path
	
					Write-Host "Get module $moduleName" -ForegroundColor Cyan
	
					$tempFile = $Env:temp + '\' + $moduleName + '.psm1'
					$finalFile = $modulePath
	
					If (Test-Path $finalFile) {
						Write-Host "- $moduleName Already Exists"
						(Invoke-WebRequest $moduleURL -UseBasicParsing).Content | Out-File -FilePath $tempFile
						Update-SNTLPS -OldFile $finalFile -NewFile $tempFile
					}
					Else {
						(Invoke-WebRequest $moduleURL -UseBasicParsing).Content | Out-File -FilePath $modulePath
					}

					$i++
					Write-Progress -Activity "Importing Modules" -Status "Current count: $i of $ModuleInfoLength" -PercentComplete (($i / $ModuleInfoLength) * 100) -CurrentOperation "Processing Module: $moduleName"
				}
			} 
			While ($i -ne $ModuleInfoLength)
		}
	}
}


#Import existing functions first
Function Update-SNTLPS {

	param(
		[Parameter(
			Mandatory = $true
		)]
		[string]$OldFile,
	  
		[Parameter(
			Mandatory = $true
		)]
		[string[]]$NewFile
	)

	$New = (Get-FileHash $NewFile -Algorithm MD5).Hash
	$Existing = (Get-FileHash $OldFile -Algorithm MD5 -ErrorAction SilentlyContinue).Hash

	If ($New -ne $Existing) {
		Write-Output "- Updating Module" -ForegroundColor green
		Move-Item -Path $NewFile -Destination $OldFile -Force
	}
	Else {
		Write-Output "- Ignoring Update" -ForegroundColor Yellow
		Remove-Item -Path $NewFile -Force -ErrorAction SilentlyContinue
	}
}

Function Get-ImportStatus {
	If (Get-Module -Name "SNTL-PS*" -ErrorAction SilentlyContinue) {
		Write-Host -NoNewLine " "; Write-Host @greenCheck; Write-Host -NoNewLine " Functions successfully loaded "; Write-Host @greenCheck; Write-Host "`n - 'Get-SNTLPS' will give a list of custom functions -`n"
	}
	Else {
		Write-Host "Functions were not successfully loaded."
	}
}

Write-Host "`n - Retrieving Sentinel Functions -"
Set-ExecutionPolicy Bypass -Scope Process -Force

$progressPreference = 'silentlyContinue'

# Custom Variables
CSVUrl = 'https://raw.githubusercontent.com/EthanHunsdale/Sentinel-Functions/main/Modules/URL-LIST.csv'

# Variables
$Global:SNTLModules = @()										# List for storing modules
$Global:UpdateFunctions = $true										# Toggle to update functions or not.
$Global:FunctionsFolder = $ENV:SystemDrive + '\Sentinel\Functions\'	# Location of functions directory.
$Global:greenCheck = @{												# Cosmetic green tick
	Object          = [Char]8730
	ForegroundColor = 'Green'
	NoNewLine       = $true
}

# Add empty functions folder if missing.
If (-not(Test-Path $FunctionsFolder)) {
	New-Item -ItemType Directory -Force -Path $FunctionsFolder | Out-Null
	$UpdateFunctions = $false
}

Enable-SSL

If ($UpdateFunctions) {
	Import-SNTLPS
	Update-SNTLPS
}
else {
	Import-SNTLPS
}

Get-ImportStatus